<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lea Ng·ªçc</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #ffe6f0, #fff);
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    .message {
      position: absolute;
      bottom: 10%;
      width: 100%;
      text-align: center;
      font-size: 1.4em;
      color: #d63384;
      font-weight: bold;
      padding: 0 10px;
      box-sizing: border-box;
    }
  </style>
</head>
<audio id="bg-music" autoplay loop>
    <!-- <source src="https://www.bensound.com/bensound-music/bensound-tenderness.mp3" type="audio/mp3"> -->
    <source src="guitar_morning_tone.mp3" type="audio/mp3">
    Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ audio.
  </audio>
<body>
  <div class="message">Lea Ng·ªçc üíï</div>
  
  <button id="play-btn" style="
  position: absolute;
  top: 20px;
  right: 20px;
  padding: 10px 15px;
  font-size: 14px;
  background: #ff69b4;
  color: white;
  border: none;
  border-radius: 20px;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  z-index: 10;
">
  üîà B·∫≠t nh·∫°c
</button>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 20;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Heart shape for small hearts
    const heartShape = new THREE.Shape();
    heartShape.moveTo(0, 0);
    heartShape.bezierCurveTo(0, 0, -1.5, -1.5, -2, 0);
    heartShape.bezierCurveTo(-2.5, 2, 0, 3, 0, 4);
    heartShape.bezierCurveTo(0, 3, 2.5, 2, 2, 0);
    heartShape.bezierCurveTo(1.5, -1.5, 0, 0, 0, 0);
    const extrudeSettings = { depth: 0.1, bevelEnabled: false };
    const smallHeartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
    smallHeartGeometry.scale(0.05, 0.05, 0.05);

    // Parametric function t·∫°o h√¨nh tr√°i tim 3D l·ªõn (d·∫°ng 2D + z ng·∫´u nhi√™n)
    function heartFunction3D(t) {
      const phi = t * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(phi), 3);
      const y =
        13 * Math.cos(phi) -
        5 * Math.cos(2 * phi) -
        2 * Math.cos(3 * phi) -
        Math.cos(4 * phi);
      const z = (Math.random() - 0.5) * 2;
      return new THREE.Vector3(x * 0.3, y * 0.3, z);
    }

    // T·∫°o tr√°i tim nh·ªè v·ªõi v·ªã tr√≠ b·∫Øt ƒë·∫ßu random ngo√†i m√†n h√¨nh
    class SmallHeart {
      constructor(targetPos) {
        const material = new THREE.MeshPhongMaterial({ color: 0xff69b4, shininess: 80 });
        this.mesh = new THREE.Mesh(smallHeartGeometry, material);

        // V·ªã tr√≠ ƒë√≠ch
        this.targetPos = targetPos.clone();

        // V·ªã tr√≠ b·∫Øt ƒë·∫ßu: random ngo√†i khung nh√¨n (t·∫°o v√≤ng tr√≤n l·ªõn quanh camera)
        const angle = Math.random() * Math.PI * 2;
        const radius = 30 + Math.random() * 20;
        this.startPos = new THREE.Vector3(
          Math.cos(angle) * radius,
          (Math.random() - 0.5) * 40,
          Math.sin(angle) * radius
        );

        this.mesh.position.copy(this.startPos);

        // V·∫≠n t·ªëc bay v√†o
        this.speed = 0.02 + Math.random() * 0.01;

        scene.add(this.mesh);

        // Tr·∫°ng th√°i ƒë√£ ƒë·∫øn n∆°i ch∆∞a
        this.arrived = false;
      }

      update() {
        if (!this.arrived) {
          // Vector h∆∞·ªõng ƒëi t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn v·ªã tr√≠ ƒë√≠ch
          const direction = new THREE.Vector3()
            .subVectors(this.targetPos, this.mesh.position)
            .normalize();

          // D·ªãch chuy·ªÉn theo h∆∞·ªõng v·ªõi t·ªëc ƒë·ªô
          this.mesh.position.addScaledVector(direction, this.speed);

          // N·∫øu g·∫ßn ƒë·∫øn ƒë√≠ch, d·ª´ng l·∫°i
          if (this.mesh.position.distanceTo(this.targetPos) < 0.1) {
            this.mesh.position.copy(this.targetPos);
            this.arrived = true;
          }
        } else {
          // ƒê·∫£o chi·ªÅu xoay nh·∫π khi ƒë√£ ƒë·∫øn
          this.mesh.rotation.x += 0.01;
          this.mesh.rotation.y += 0.01;
          // Nh·ªãp l·∫Øc nh·∫π
          this.mesh.position.y += Math.sin(Date.now() * 0.002 + this.mesh.position.x) * 0.002;
        }
      }
    }

    // T·∫°o danh s√°ch tr√°i tim nh·ªè
    const smallHearts = [];
    const totalHearts = 300;

    for (let i = 0; i < totalHearts; i++) {
      const t = i / totalHearts;
      const pos = heartFunction3D(t);
      smallHearts.push(new SmallHeart(pos));
    }

    // √Ånh s√°ng
    const pointLight = new THREE.PointLight(0xffffff, 1.5);
    pointLight.position.set(20, 20, 20);
    scene.add(pointLight);

    scene.add(new THREE.AmbientLight(0xffc0cb, 0.5));

    // Animate
    function animate() {
      requestAnimationFrame(animate);

      smallHearts.forEach((heart) => heart.update());

      // Xoay to√†n b·ªô scene nh·∫π
      scene.rotation.y += 0.002;

      renderer.render(scene, camera);
    }

    animate();

    // Responsive
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    const music = document.getElementById('bg-music');
  const btn = document.getElementById('play-btn');

  btn.addEventListener('click', () => {
    music.play();
    // btn.style.display = 'none'; // ·∫©n n√∫t sau khi b·∫≠t
  });

  // ·∫®n n√∫t n·∫øu nh·∫°c ƒë√£ ph√°t t·ª± ƒë·ªông ƒë∆∞·ª£c
  music.onplay = () => {
    // btn.style.display = 'none';
  };
  </script>
</body>
</html>
